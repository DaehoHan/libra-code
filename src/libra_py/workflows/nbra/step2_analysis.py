#***********************************************************
# * Copyright (C) 2017-2019 Brendan A. Smith, Wei Li, and Alexey V. Akimov
# * This file is distributed under the terms of the
# * GNU General Public License as published by the
# * Free Software Foundation; either version 3 of the
# * License, or (at your option) any later version.
# * http://www.gnu.org/copyleft/gpl.txt
#***********************************************************/

"""
.. module:: step2_analysis
   :platform: Unix, Windows
   :synopsis: This module implements functions for postprocessing the data generated by the 
       step2 module functions

.. moduleauthor:: Brendan A. Smith, Wei Li, and Alexey V. Akimov

"""


import os
import sys
import math

# Fisrt, we add the location of the library to test to the PYTHON path
if sys.platform=="cygwin":
    from cyglibra_core import *
elif sys.platform=="linux" or sys.platform=="linux2":
    from liblibra_core import *
#from libra_py import *
import libra_py.common_utils as comn


def takeFirst(elem):
    return elem[0]

def takeSecond(elem):
    return elem[1]



def compute_oscillator_strengths(Hvib, Hprime_x, Hprime_y, Hprime_z, params):
    """Auxiliary function for the computation of the absorption/emission spectrum of the system

    https://en.wikipedia.org/wiki/Oscillator_strength

    Args:
        Hvib ( list of CMATRIX ): "vibronic" Hamiltonians along the trajectory [units: a.u.]
        Hprime_x ( list of CMATRIX ): i*hbar*<i|p_x|j> matrices along the trajectory [units: a.u.]
        Hprime_y ( list of CMATRIX ): i*hbar*<i|p_y|j> matrices along the trajectory [units: a.u.]
        Hprime_z ( list of CMATRIX ): i*hbar*<i|p_z|j> matrices along the trajectory [units: a.u.]

    Returns:
        [ [dE, f_ij, istep, i, j] ...], where:

            * dE ( double ): energy gap [units: a.u.]
            * f_ij ( double ): oscillator strength for a given transition [units: a.u.]
            * istep ( int ): index of the time step along the given trajectory
            * i ( int ): index of the initial (from where) state
            * j ( int ): index of the final (to where) state
    
    """

    homo = params["HOMO"]

    nsteps = len(Hvib)
    nmo = Hvib[0].num_of_cols


    res = []
    for istep in xrange(nsteps):             # All data points
 
        for i in xrange(homo+1):            # All occupied orbitals
            for j in xrange(homo+1, nmo):   # All unoccupied orbitals

                dE = Hvib[istep].get(j,j).real - Hvib[istep].get(i,i).real  # >= 0.0

                X = Hprime_x[istep].get(i,j)
                X2 = (X.conjugate() * X ).real

                Y = Hprime_y[istep].get(i,j)
                Y2 = (Y.conjugate() * Y ).real

                Z = Hprime_z[istep].get(i,j)
                Z2 = (Z.conjugate() * Z ).real

                f_ij = 0.0
                if dE>0.0:
                    f_ij = (2.0/3.0)*( X2 + Y2 + Z2 )*(1.0/dE) 

                res.append([dE, f_ij, istep, i, j])

    return res



def compute_spectrum(Hvib, Hprime_x, Hprime_y, Hprime_z, params):
    """Auxiliary function for the computation of the absorption/emission spectrum of the system

    https://en.wikipedia.org/wiki/Oscillator_strength

    Args:
        Hvib ( list of CMATRIX ): "vibronic" Hamiltonians along the trajectory [units: a.u.]
        Hprime_x ( list of CMATRIX ): i*hbar*<i|p_x|j> matrices along the trajectory [units: a.u.]
        Hprime_y ( list of CMATRIX ): i*hbar*<i|p_y|j> matrices along the trajectory [units: a.u.]
        Hprime_z ( list of CMATRIX ): i*hbar*<i|p_z|j> matrices along the trajectory [units: a.u.]

    Returns:
        tuple: ( E, osc_str, istep, init_st, fin_st ), where are the sorted data:

            * E ( list of doubles ): energy gaps [units: a.u.]
            * osc_str ( list of doubles ): oscillator strengths [units: a.u.]
            * istep ( list of ints ): indices of the time steps
            * init_st ( int ): indices of the initial states
            * fin_st ( int ): indices of the final states

    """

    opt = params["opt"]

    res = compute_oscillator_strengths(Hvib, Hprime_x, Hprime_y, Hprime_z, params)

    # sort list with key
    sorted_res = None

    if opt==0:  # sort by energies
        sorted_res = sorted(res, key=takeFirst)

    elif opt==1:  # sort by the magnitude of oscillator strength
        sorted_res = sorted(res, key=takeSecond)


    # Unpack the data into separate lists
    E, osc_str, istep, init_st, fin_st = [], [], [], [], []
    for it in sorted_res:
        E.append(it[0])
        osc_str.append(it[1])
        istep.append(it[2])
        init_st.append(it[3])
        fin_st.append(it[4])


    return E, osc_str, istep, init_st, fin_st



